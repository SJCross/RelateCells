// TODO: Load single image

package wbif.sjx.RelateCells;

import fiji.plugin.trackmate.*;
import fiji.plugin.trackmate.detection.DetectorKeys;
import fiji.plugin.trackmate.detection.LogDetectorFactory;
import fiji.plugin.trackmate.features.spot.SpotIntensityAnalyzerFactory;
import fiji.plugin.trackmate.tracking.LAPUtils;
import fiji.plugin.trackmate.tracking.oldlap.SimpleLAPTrackerFactory;
import ij.IJ;
import ij.ImagePlus;
import ij.ImageStack;
import ij.Prefs;
import ij.gui.GenericDialog;
import ij.gui.Line;
import ij.gui.OvalRoi;
import ij.gui.Overlay;
import ij.gui.PolygonRoi;
import ij.gui.Roi;
import ij.measure.Measurements;
import ij.plugin.AVI_Reader;
import ij.plugin.ChannelSplitter;
import ij.plugin.Duplicator;
import ij.plugin.ImageCalculator;
import ij.plugin.PlugIn;
import ij.plugin.RGBStackMerge;
import ij.plugin.filter.BackgroundSubtracter;
import ij.plugin.filter.GaussianBlur;
import ij.plugin.filter.ParticleAnalyzer;
import ij.plugin.frame.RoiManager;
import ij.process.AutoThresholder;
import ij.process.ImageConverter;
import ij.process.StackConverter;
import ij.process.StackProcessor;
import ij.process.StackStatistics;
import org.apache.commons.io.FilenameUtils;
import org.apache.hadoop.hbase.util.MunkresAssignment;
import org.w3c.dom.Attr;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import wbif.sjx.common.FileConditions.ExtensionMatchesString;
import wbif.sjx.common.FileConditions.NameContainsPattern;
import wbif.sjx.common.FileConditions.NameContainsString;
import wbif.sjx.common.MetadataExtractors.IncuCyteShortFilenameExtractor;
import wbif.sjx.common.Object.HCMetadata;
import wbif.sjx.common.Object.SpotIntensity;
import wbif.sjx.common.System.FileCrawler;

import javax.swing.JFileChooser;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerException;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;
import java.awt.Color;
import java.io.File;
import java.text.DecimalFormat;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Random;
import java.util.regex.Pattern;

public class Relate_Cells implements PlugIn{
    private int maxCellID = 0; // Fluorescence-channel and phase-channel cells draw from the same pool

    public static void main(String[] args) throws TransformerException, ParserConfigurationException {
        new Relate_Cells().run();

    }

    private void run() throws TransformerException, ParserConfigurationException {
        // Starting ImageJ
        //new ImageJ()

        // Getting parameters via a generic dialog
        HashMap<String,Object> params = getParameters();

        // Initialising ArrayList to hold results.  The overall result will hold an ArrayList of Result objects for that
        // experiment
        IJ.log("Initialising system");
        ArrayList<ArrayList<Result>> results = new ArrayList<>();

        // Setting up a condition to only load images with the IncuCyte filename format
        IncuCyteShortFilenameExtractor patternExtractor = new IncuCyteShortFilenameExtractor();
        Pattern filePattern = Pattern.compile(patternExtractor.getPattern());
        NameContainsPattern filePatternCondition = new NameContainsPattern(filePattern, NameContainsPattern.INC_PARTIAL);

        // Setting up a condition to only load images containing the fluorescence name (i.e. fluorescence images)
        NameContainsString fileNameCondition = new NameContainsString((String) params.get("Fl_name"),NameContainsString.INC_PARTIAL);

        // Setting up a condition which ignores the overlay images generated by this analysis
        NameContainsString overlayCondition = new NameContainsString("celloverlay",NameContainsString.EXC_PARTIAL);

        // Setting up a condition to only load images with .tif, .tiff or .avi extensions
        String[] exts = new String[]{"tif", "tiff","avi"};
        ExtensionMatchesString extensionConditon = new ExtensionMatchesString(exts);

        // Getting the root folder for analysis
        File rootFolder = new File((String) params.get("Root_folder"));

        // Initialising FileCrawler based on previously identified criteria
        FileCrawler fileCrawler = new FileCrawler();
        fileCrawler.setRootFolder(rootFolder);
        fileCrawler.addFileCondition(filePatternCondition);
        fileCrawler.addFileCondition(fileNameCondition);
        fileCrawler.addFileCondition(overlayCondition);
        fileCrawler.addFileCondition(extensionConditon);

        // Calculating the number of files that will be processed
        int numFiles = fileCrawler.getNumberOfValidFilesInStructure();
        IJ.log(numFiles+" image stacks to process");

        // Re-initialising the FileCrawler
        fileCrawler = new FileCrawler();
        fileCrawler.setRootFolder(rootFolder);
        fileCrawler.addFileCondition(filePatternCondition);
        fileCrawler.addFileCondition(fileNameCondition);
        fileCrawler.addFileCondition(overlayCondition);
        fileCrawler.addFileCondition(extensionConditon);

        // Running through all compatible files in the structure
        int iter = 1;
        File file = fileCrawler.getNextValidFileInStructure();
        while (file != null) {
            IJ.log(" ");
            IJ.log("Processing image stack " + iter + ":");

            // Creating the result structure for the current file
            IJ.log("    Extracting metadata:");
            Result result = new Result();
            result.setFile(file);

            patternExtractor.extract(result,file.getName());
            IJ.log("        Well: " + result.getWell());
            IJ.log("        Field: " + result.getField());

            // Loading current image stack
            ImagePlus ipl = loadImages(file, result, params);

            if (ipl != null) {
                // Running stack alignment
                ipl = runDriftCorrection(ipl, params);

                // Running the cell relation process and adding the results to the cumulative results collection
                ArrayList<Result>  currResults = runRelation(ipl, params, result);
                results.add(currResults);

            } else {
                IJ.log("    Missing phase contrast file");
            }

            // Loading the next valid file
            file = fileCrawler.getNextValidFileInStructure();

            iter++;

        }

        exportResultsXML(results,params);

    }

    private static HashMap<String,Object> getParameters() {

        String flName = Prefs.get("RelateCells.flName","Green");
        String pHName = Prefs.get("RelateCells.pHName","Phase");
        double borderWidth = Prefs.get("RelateCells.borderWidth",5);
        double dogRadius = Prefs.get("RelateCells.dogRadius",4);
        double threshMult = Prefs.get("RelateCells.threshMult",1);
        double minSize = Prefs.get("RelateCells.minSize",10);
        double maxSize = Prefs.get("RelateCells.maxSize",100000);
        double maxEdgeDist = Prefs.get("RelateCells.maxEdgeDist",20);
        double maxCentDist = Prefs.get("RelateCells.maxCentDist",50);
        boolean invertIntensity = Prefs.get("RelateCells.invertIntensity",false);
        double detectionRadius = Prefs.get("RelateCells.detectionRadius",7.5);
        double threshold = Prefs.get("RelateCells.threshold",2);
        double minIntensity = Prefs.get("RelateCells.minIntensity",20);
        boolean saveDetection = Prefs.get("RelateCells.saveDetection",true);

        GenericDialog gd = new GenericDialog("Parameters");
        gd.addMessage("GENERAL:");
        gd.addStringField("Fluorescence channel name",flName,4);
        gd.addStringField("Phase contrast channel name",pHName,4);
        gd.addNumericField("Border width (%): ",borderWidth,0);
        gd.addMessage(" ");
        gd.addMessage("FLUORESCENCE CHANNEL:");
        gd.addNumericField("DoG filter radius (px): ", dogRadius, 1);
        gd.addNumericField("Threshold multiplier: ", threshMult, 1);
        gd.addNumericField("Minimum cell size (px^2)", minSize, 1);
        gd.addNumericField("Maximum cell size (px^2)", maxSize, 1);
        gd.addNumericField(" Max. edge-edge distance (px): ", maxEdgeDist, 1);
        gd.addNumericField("Max. centroid-centroid distance (px): ", maxCentDist, 1);
        gd.addCheckbox("Invert intensity",invertIntensity);
        gd.addMessage(" ");
        gd.addMessage("PHASE CONTRAST CHANNEL:");
        gd.addNumericField("Detection radius (px): ", detectionRadius, 1);
        gd.addNumericField("Threshold (px): ", threshold, 1);
        gd.addNumericField("Minimum intensity (AU): ",minIntensity,20);
        gd.addMessage(" ");
        gd.addMessage("OUTPUT:");
        gd.addCheckbox("Save detection and links",saveDetection);

        gd.showDialog();

        // Parameters
        flName = gd.getNextString();
        pHName = gd.getNextString();
        borderWidth = gd.getNextNumber();
        dogRadius = gd.getNextNumber();
        threshMult = gd.getNextNumber();
        minSize = gd.getNextNumber();
        maxSize = gd.getNextNumber();
        maxEdgeDist = gd.getNextNumber();
        maxCentDist = gd.getNextNumber();
        invertIntensity = gd.getNextBoolean();
        detectionRadius = gd.getNextNumber();
        threshold = gd.getNextNumber();
        minIntensity = gd.getNextNumber();
        saveDetection = gd.getNextBoolean();

        HashMap<String,Object> params = new HashMap<>();
        params.put("Fl_name",flName);
        params.put("Ph_name",pHName);
        params.put("Border_width",borderWidth); // Percentage width of the border following drift correction
        params.put("DoG_Radius",dogRadius); // Radius for smaller Gaussian blur in DoG filtering (larger is 1.6*dogR)
        params.put("Threshold_multiplier",threshMult);
        params.put("Min_fl_cell_size",minSize);
        params.put("Max_fl_cell_size",maxSize);
        params.put("Max_Link_Threshold",maxEdgeDist); // Distance in px from one cell boundary to the other
        params.put("Centroid_Link_Threshold",maxCentDist); // Centroid distance for accurate edge-edge distance to be calculated
        params.put("Invert_intensity",invertIntensity); // Inverting the intensity appears necessary for some ImageJ versions (not sure why yet)
        params.put("TrackMate_Radius",detectionRadius);
        params.put("TrackMate_Threshold",threshold);
        params.put("Min_ph_intensity",minIntensity);
        params.put("Display_Links",saveDetection);

        // Getting root folder for analysis
        File rootFolder = getRootFolder();
        params.put("Root_folder",rootFolder.getAbsolutePath());

        // Getting export location for the Excel file
        File exportFile = getExportLocation();
        params.put("Export_file",exportFile.getAbsolutePath());

        return params;

    }

    private static File getRootFolder() {
        // Opening the file dialog.  Only directories can be selected
        JFileChooser openFileDialog = new JFileChooser("C:\\Users\\sc13967\\Google Drive\\People\\H\\Lea Hampton-O'Neil\\2017-03-07 Cell association (Incucyte)\\Batch data\\Crop");
        openFileDialog.setDialogTitle("Select the root folder");
        openFileDialog.setMultiSelectionEnabled(false);
        openFileDialog.setFileSelectionMode(JFileChooser.DIRECTORIES_ONLY);
        openFileDialog.showOpenDialog(null);

        return openFileDialog.getSelectedFile();

    }

    private static File getExportLocation() {
        // Opening the file dialog.  Only directories can be selected
        JFileChooser openFileDialog = new JFileChooser();
        openFileDialog.setDialogTitle("Select file to save");
        openFileDialog.setMultiSelectionEnabled(false);
        openFileDialog.setFileSelectionMode(JFileChooser.FILES_ONLY);
        openFileDialog.showOpenDialog(null);
        return openFileDialog.getSelectedFile();

    }

    private static ImagePlus loadImages(File file, HCMetadata result, HashMap<String,Object> params) {
        // Getting the filename for the corresponding phase-contrast image
        String comment = result.getComment();
        comment = comment.replaceAll((String) params.get("Fl_name"),(String) params.get("Ph_name"));
        String phFilename = IncuCyteShortFilenameExtractor.generate(comment,result.getWell(),String.valueOf(result.getField()),result.getExt());

        // Creating structure to hold both image stacks
        ImagePlus[] ipls = new ImagePlus[2];

        // Checking the phase channel also exists
        if (new File(file.getParentFile().getAbsolutePath() + "\\" + phFilename).exists()) {
            // Selecting the method to use for image opening depending on the file type
            if (result.getExt().equals("avi")) {
                // Loading the current fluorescence channel file to ImageJ
                IJ.log("    Loading fluorescence image stack (" + file.getName() + ")");
                ipls[0] = AVI_Reader.open(file.getAbsolutePath(), false);
                new StackConverter(ipls[0]).convertToGray8();

                // Loading the current phase-contrast channel file to ImageJ
                IJ.log("    Loading phase-contrast image stack (" + phFilename + ")");
                ipls[1] = AVI_Reader.open(file.getParentFile().getAbsolutePath() + "\\" + phFilename, false);
                new StackConverter(ipls[1]).convertToGray8();

            } else if (result.getExt().equals("tif") | result.getExt().equals("tiff")) {
                // Loading the current fluorescence channel file to ImageJ
                IJ.log("    Loading fluorescence image stack (" + file.getName() + ")");
                ipls[0] = IJ.openImage(file.getAbsolutePath());

                // Loading the current phase-contrast channel file to ImageJ
                IJ.log("    Loading phase-contrast image stack (" + phFilename + ")");
                ipls[1] = IJ.openImage(file.getParentFile().getAbsolutePath() + "\\" + phFilename);

            }

            // Combining the two images for stack registration
            IJ.log("    Creating composite image");
            ImagePlus ipl = RGBStackMerge.mergeChannels(ipls, false);

            // Converting ImagePlus to time-based if there are more slices than frames and the number of frames is 1
            if (ipl.getNSlices() > 1 & ipl.getNFrames() == 1) {
                switchTimeAndZ(ipl);
            }

            return ipl;

        } else {
            return null;

        }

    }

    private static ImagePlus runDriftCorrection(ImagePlus ipl, HashMap<String,Object> params) {
        new StackConverter(ipl).convertToRGB();

        // Running stack registration
        IJ.log("    Aligning image stack using StackReg");
        ipl.setT(ipl.getNFrames());
        IJ.run(ipl,"StackReg","transformation=Translation");

        //Converting back to a composite image
        ImagePlus[] ipls = ChannelSplitter.split(ipl);
        ImagePlus[] ipls2 = new ImagePlus[]{ipls[0],ipls[1]};
        ipl = RGBStackMerge.mergeChannels(ipls2,false);

        // Cropping the image to the central region
        Double borderFrac = (double) params.get("Border_width")/100;
        int w = ipl.getWidth();
        int h = ipl.getHeight();
        ImageStack ist = new StackProcessor(ipl.getStack()).crop(
                ((Double) (w*borderFrac)).intValue(),
                ((Double) (h*borderFrac)).intValue(),
                ((Double) (w*(1-2*borderFrac))).intValue(),
                ((Double) (h*(1-2*borderFrac))).intValue());
        ipl.setStack(ist);

        // Converting ImagePlus to time-based if there are more slices than frames and the number of frames is 1
        if (ipl.getNSlices() > 1 & ipl.getNFrames() == 1) {
            switchTimeAndZ(ipl);
        }

        return ipl;

    }

    private ArrayList<Result> runRelation(ImagePlus ipl, HashMap<String,Object> params, Result templateResult) {
        // Getting the separate channels
        ImagePlus[] ipls = ChannelSplitter.split(ipl);

        // Calculating the difference of Gaussian for the phase-contrast channel
        IJ.log("    Running DoG filter on phase-contrast channel");
        ImagePlus phaseIpl = runDoG(ipls[1],(double) params.get("DoG_Radius"));

        // Creating a separate image to perform fluorescence operations on
        ImagePlus fluorIpl = new Duplicator().run(ipls[0]);

        // Detecting cells in the phase-contrast channel
        IJ.log("    Detecting cells in phase-contrast channel using TrackMate");
        ArrayList<Cell> phCells = detectPhaseContrastCells(phaseIpl, ipls[1], params);
        IJ.log("        "+phCells.size()+" instances found");

        // Detecting cells in the fluorescence channel
        IJ.log("    Detecting cells in fluorescence channel");
        ArrayList<Cell> flCells = detectFluorescentCells(fluorIpl, params);
        IJ.log("        "+flCells.size()+" instances found");

        // Linking phase contrast cells to tracks
        IJ.log("    Tracking cells in fluorescence channel using Apache HBase (MunkresAssignment)");
        HashMap<Integer,ArrayList<Cell>> tracks = trackCells(flCells);
        IJ.log("        "+tracks.size()+" tracks created");

        // Removing overlapping cells (where fluorescent cells were detected in the phase channel)
        IJ.log("    Removing overlapping cells");
        removingCellOverlap(phCells, flCells);

        // Linking phase channel cells to fluorescence channel cells
        IJ.log("    Linking fluorescence and phase-contrast cells");
        compareCellPositions(phCells, flCells, (double) params.get("Max_Link_Threshold"), (double) params.get("Centroid_Link_Threshold"));

        // Calculating number of phase cells per frame
        IJ.log("    Calculating number of cells per frame in phase-contrast channel");
        int[] phCellsPerFrame = measureNumCellsPerFrame(phCells, ipl.getNFrames());

        // Displaying the tracked cells on the fluorescence channel
        if ((boolean) params.get("Display_Links")) {
            IJ.log("    Saving overlay image");
            String outPname = FilenameUtils.removeExtension(templateResult.getFile().getAbsolutePath())+"_celloverlay.tif";
            showLinkedCells(phCells, flCells, ipl, outPname);

        }

        // Compiling results into an ArrayList of results
        return compileResult(templateResult,tracks,phCellsPerFrame);

    }

    /**
     * Converts a hyperstack with time listed in the Z-dimension to having frames in T.  Uses the same approach as
     * TrackMate
     * @param ipl Input ImagePlus
     */
    private static void switchTimeAndZ(ImagePlus ipl) {
        int[] dimensions = ipl.getDimensions();
        ipl.setDimensions(dimensions[2],dimensions[4],dimensions[3]);

    }

    private static ImagePlus runDoG(ImagePlus ipl, double sigma) {
        // Duplicating the input ImagePlus
        ImagePlus ipl1 = new Duplicator().run(ipl);
        ImagePlus ipl2 = new Duplicator().run(ipl);

        // Converting both ImagePlus into 32-bit, to give a smoother final result
        new ImageConverter(ipl1).convertToGray32();
        new ImageConverter(ipl2).convertToGray32();

        // Performing the next couple of steps on all slices
        for (int i = 0; i < ipl.getNFrames(); i++) {
            // Setting the current slice number
            ipl1.setT(i+1);
            ipl2.setT(i+1);

            // Multiplying the intensities by 10, to give a smoother final result
            ipl1.getProcessor().multiply(10);
            ipl2.getProcessor().multiply(10);

            // Running Gaussian blur at two length scales.  One 1.6 times larger than the other (based on discussion at
            // http://dsp.stackexchange.com/questions/2529/what-is-the-relationship-between-the-sigma-in-the-laplacian-of-
            // gaussian-and-the (Accessed 14-03-2017)
            new GaussianBlur().blurGaussian(ipl1.getProcessor(), sigma, sigma, 0.01);
            new GaussianBlur().blurGaussian(ipl2.getProcessor(), sigma * 1.6, sigma * 1.6, 0.01);
        }

        // Subtracting one from the other to give the final DoG result
        ImagePlus iplOut = new ImageCalculator().run("Subtract create stack 32-bit",ipl2,ipl1);

        new ImageConverter(iplOut).convertToGray8();

        return iplOut;

    }

    private ArrayList<Cell> detectPhaseContrastCells(ImagePlus ipl, ImagePlus rawIpl, HashMap<String,Object> params) {
        Model model = new Model();

        // Disabling logging
        model.setLogger(Logger.VOID_LOGGER);

        Settings settings = new Settings();
        settings.setFrom(ipl);

        settings.detectorFactory = new LogDetectorFactory();
        settings.detectorSettings.put(DetectorKeys.KEY_DO_SUBPIXEL_LOCALIZATION,true);
        settings.detectorSettings.put(DetectorKeys.KEY_RADIUS,params.get("TrackMate_Radius"));
        settings.detectorSettings.put(DetectorKeys.KEY_TARGET_CHANNEL,1);
        settings.detectorSettings.put(DetectorKeys.KEY_THRESHOLD,params.get("TrackMate_Threshold"));
        settings.detectorSettings.put(DetectorKeys.KEY_DO_MEDIAN_FILTERING,false);

        settings.trackerFactory = new SimpleLAPTrackerFactory();
        settings.trackerSettings = LAPUtils.getDefaultLAPSettingsMap();

        settings.addSpotAnalyzerFactory(new SpotIntensityAnalyzerFactory());

        TrackMate trackmate = new TrackMate(model,settings);

        if (!trackmate.checkInput()) {
            IJ.log(trackmate.getErrorMessage());
        }

        trackmate.execDetection();
        trackmate.execInitialSpotFiltering();
        trackmate.computeSpotFeatures(true);
        trackmate.execSpotFiltering(true);

        ArrayList<Cell> cells = new ArrayList<>();
        SpotCollection spots = model.getSpots();
        double minInt = (double) params.get("Min_ph_intensity");

        spots.iterable(true).forEach(it -> {
            // Removing black cells, which can arise when they are accidentally detected at the image edge following
            // drift correction
            rawIpl.setPosition(1,1,it.getFeature(Spot.POSITION_T).intValue()+1);
            SpotIntensity intensity = new SpotIntensity(
                    rawIpl.getProcessor(),
                    it.getFeature(Spot.POSITION_X),
                    it.getFeature(Spot.POSITION_Y),
                    it.getFeature(Spot.RADIUS) / 1.5);

            if (intensity.getMeanPointIntensity() > minInt) {
                double rad = it.getFeature(Spot.RADIUS);
                OvalRoi ovalRoi = new OvalRoi(it.getFeature(Spot.POSITION_X) - rad, it.getFeature(Spot.POSITION_Y) - rad, rad * 2, rad * 2);
                Cell cell = new Cell(ovalRoi.getFloatPolygon().xpoints, ovalRoi.getFloatPolygon().ypoints, Roi.POLYGON);
                cell.setPosition(it.getFeature(Spot.POSITION_T).intValue() + 1);

                cells.add(cell);
            }
        });

        return cells;
    }

    private ArrayList<Cell> detectFluorescentCells(ImagePlus ipl, HashMap<String,Object> params) {
        // Applying basic image processing to clean up the image
        // Performing the next couple of steps on all slices
        for (int i = 0; i < ipl.getNFrames(); i++) {
            // Setting the current slice number
            int frame = i+1;
            ipl.setT(frame);

            new BackgroundSubtracter().rollingBallBackground(ipl.getProcessor(),50,false,false,false,true,true);
            new GaussianBlur().blurGaussian(ipl.getProcessor(),2,2,0.01);

        }

        // Getting the stack intensity histogram
        StackStatistics stackStats = new StackStatistics(ipl);
        int[] statLong = stackStats.histogram;
        int[] statInt = new int[statLong.length];

        // Converting long-format image stack histogram measurements to int-format
        for (int i=0;i<statLong.length;i++) {
            statInt[i] = Math.toIntExact(statLong[i]);
        }

        // Determining the threshold (Huang method) and casting to double, for the multiplication step
        double thresh = (double) new AutoThresholder().getThreshold(AutoThresholder.Method.Otsu,statInt);
        IJ.log("        Threshold (Otsu) set to "+thresh);

        // Applying user-specified offset, the converting back to int
        thresh = ((Double) (thresh*(double) params.get("Threshold_multiplier"))).intValue();
        IJ.log("        Threshold offset to "+thresh+" ("+params.get("Threshold_multiplier")+"x)");

        // Running the threshold on each image in the stack
        for (int i=0;i<ipl.getNFrames();i++) {
            ipl.setT(i+1);
            ipl.getProcessor().threshold(((Double) thresh).intValue());

        }

        // Creating a container for the cells and a RoiManager, where the results will be stored temporarily
        ArrayList<Cell> cells = new ArrayList<>();
        RoiManager rois = RoiManager.getRoiManager();
        rois.setVisible(false);

        // Running through each slice (frame), detecting the particles
        for (int frame=0;frame<ipl.getNFrames();frame++) {
            ipl.setT(frame+1);

            // Inverting the intensity.  This seems necessary for some versions of ImageJ, but not others :/
            if ((boolean) params.get("Invert_intensity")) {
                ipl.getProcessor().invert();
            }

            // Running analyse particles
            ParticleAnalyzer partAnal = new ParticleAnalyzer(
                    ParticleAnalyzer.EXCLUDE_EDGE_PARTICLES,
                    Measurements.AREA | Measurements.CENTROID,
                    null,
                    Math.round((double) params.get("Min_fl_cell_size")),
                    Math.round((double) params.get("Max_fl_cell_size")),
                    0, 1);
            ParticleAnalyzer.setRoiManager(rois);
            partAnal.analyze(ipl);

            // Adding all current rois to the cell arraylist
            for (int i = 0; i < rois.getCount(); i++) {
                Cell cell = new Cell(rois.getRoi(i).getPolygon(), PolygonRoi.POLYGON);
                cell.setPosition(frame+1);
                cells.add(cell);

            }

            // Removing the previously-detected ROIs from the RoiManager
            rois.reset();
        }

        return cells;

    }

    /**
     * Links cells using the Munkres algorithm.
     * @return HashMap containing ArrayLists of cells, sorted by the TrackID number
     */
    private static HashMap<Integer,ArrayList<Cell>> trackCells(ArrayList<Cell> cells) {
        double maxDist = 100;

        HashMap<Integer,ArrayList<Cell>> tracks = new HashMap<>();

        // Getting the maximum frame number
        int maxFr = 0;
        for (Cell cell:cells) {
            if (cell.getPosition() > maxFr) {
                maxFr = cell.getPosition();
            }
        }

        int trackID = 0;
        Random rand = new Random(System.currentTimeMillis());
        // Assigning new trackIDs to all cells in the first frame
        for (Cell cell:cells) {
            if (cell.getPosition() == 1) {
                // Assigning the next available track number to this track
                cell.setTrackID(trackID++);

                // Creating a new track ArrayList and adding it to the tracks ArrayList
                ArrayList<Cell> track = new ArrayList<>();
                track.add(cell);
                tracks.put(cell.getTrackID(),track);

                // Assigning a random colour to this new track
                cell.setColour(Color.getHSBColor(rand.nextFloat(),1,1));
            }
        }

        // Going through each frame, getting the current cells and the ones from the previous frame
        for (int fr = 2; fr <= maxFr; fr++) {
            ArrayList<Cell> prevCells = new ArrayList<>();
            ArrayList<Cell> currCells = new ArrayList<>();

            for (Cell cell:cells) {
                if (cell.getPosition() + 1 == fr) {
                    prevCells.add(cell);
                } else if (cell.getPosition() == fr) {
                    currCells.add(cell);
                }
            }

            if (currCells.size() > 0) {
                // Creating a 2D cost matrix for the overlap.  A maximum linking distance is specified, above which costs are Inf
                float[][] cost = new float[currCells.size()][prevCells.size()];
                for (int curr = 0; curr < cost.length; curr++) {
                    for (int prev = 0; prev < cost[0].length; prev++) {
                        double[] currCent = currCells.get(curr).getContourCentroid();
                        double[] prevCent = prevCells.get(prev).getContourCentroid();

                        double dist = Math.sqrt((prevCent[0] - currCent[0]) * (prevCent[0] - currCent[0]) + (prevCent[1] - currCent[1]) * (prevCent[1] - currCent[1]));

                        if (dist < maxDist) {
                            cost[curr][prev] = (float) dist;
                        } else {
                            cost[curr][prev] = Float.MAX_VALUE;
                        }
                    }
                }

                // Running the Munkres algorithm to assign matches.
                int[] assignment = new MunkresAssignment(cost).solve();

                // Applying the calculated track IDs to the cells
                for (int curr = 0; curr < assignment.length; curr++) {
                    if (assignment[curr] == -1) {
                        Cell currCell = currCells.get(curr);
                        // Assigning the next available track number to this track
                        currCell.setTrackID(trackID++);

                        // Creating a new track ArrayList and adding it to the tracks ArrayList
                        ArrayList<Cell> track = new ArrayList<>();
                        track.add(currCell);
                        tracks.put(currCell.getTrackID(), track);

                        // Assigning a random colour to this new track
                        currCell.setColour(Color.getHSBColor(rand.nextFloat(), 1, 1));

                    } else {
                        // Applying TrackID and colour from the previous cell to the newly linked cell
                        Cell prevCell = prevCells.get(assignment[curr]);
                        Cell currCell = currCells.get(curr);
                        currCell.setTrackID(prevCell.getTrackID());
                        currCell.setColour(prevCell.getColour());

                        // Adding the new object to that track
                        tracks.get(prevCell.getTrackID()).add(currCell);

                    }
                }
            }
        }

        return tracks;

    }

    private static void removingCellOverlap(ArrayList<Cell> phCells, ArrayList<Cell> flCells) {
        for (int i=phCells.size()-1;i>=0;i--) {
            IJ.showProgress((phCells.size() - i) / phCells.size());
            Cell phCell = phCells.get(i);
            for (Cell flCell : flCells) {
                // Only testing for a link if the cells are visible in the same frame
                if (phCell.getPosition() == flCell.getPosition()) {
                    // Performing a crude spatial test to check if they are remotely close
                    double[] phCent = phCell.getContourCentroid();

                    // Testing if the phase channel cell is within the boundary of the fluorescent channel cell.  This
                    // can arise from mis-detection during the DoG/TrackMate steps
                    if (flCell.contains(((Double) phCent[0]).intValue(), ((Double) phCent[1]).intValue())) {
                        phCells.remove(i);

                    }
                }
            }
        }
    }

    /**
     * Basic analysis taking cells in each frame as isolated objects.
     */
    private static void compareCellPositions(ArrayList<Cell> phCells, ArrayList<Cell> flCells, double maxLinkDist, double centLinkDist) {
        // Running through all cells in both the fluorescence and phase channels

        for (int i=phCells.size()-1;i>=0;i--) {
            IJ.showProgress((phCells.size()-i)/phCells.size());
            Cell phCell = phCells.get(i);
            for (Cell flCell:flCells) {
                // Only testing for a link if the cells are visible in the same frame
                if (phCell.getPosition() == flCell.getPosition()) {
                    // Performing a crude spatial test to check if they are remotely close
                    double[] phCent = phCell.getContourCentroid();
                    double[] flCent = flCell.getContourCentroid();

                    // Calculating a crude centre-centre cell distance to identify cells for further comparison
                    double centDist = Math.sqrt((phCent[0] - flCent[0]) * (phCent[0] - flCent[0]) + (phCent[1] - flCent[1]) * (phCent[1] - flCent[1]));

                    if (centDist < centLinkDist) {
                        // Calculating the distance between the cells
                        double dist = flCell.measureDistanceToCell(phCell);

                        // If the distance is less than the user-defined threshold ("maxLinkDist") adding reference to
                        // the other cell in each cell's linkedCells ArrayList
                        if (dist < maxLinkDist) {
                            flCell.addLinkedCell(phCell);
                            phCell.addLinkedCell(flCell);

                        }
                    }
                }
            }
        }
    }

    private static int[] measureNumCellsPerFrame(ArrayList<Cell> cells, int nFrames) {
        // Initialising the results array
        int[] numCells = new int[nFrames];

        for (Cell cell:cells) {
            numCells[cell.getPosition()-1]++;
        }

        return numCells;

    }

    private static void showLinkedCells(ArrayList<Cell> phCells, ArrayList<Cell> flCells, ImagePlus ipl, String pathOut) {
        Overlay overlay = new Overlay();

        // Adding phase-channel cells to the overlay
        for (Cell cell:phCells) {
            cell.setStrokeColor(cell.getColour());
            overlay.add(cell);

        }

        // Creating a new copy of the input image to draw the overlay on and save
        ImagePlus renderIpl = new Duplicator().run(ipl);

        // Setting LUTs for the two channels
        renderIpl.setC(1);
        IJ.run(renderIpl,"Green","");
        renderIpl.setC(2);
        IJ.run(renderIpl,"Grays","");

        new StackConverter(renderIpl).convertToRGB();

        // Adding fluorescence-channel cells to the overlay and links to phase channel cells
        for (Cell cell:flCells) {
            cell.setStrokeColor(cell.getColour());
            overlay.add(cell);

            ArrayList<Cell> links = cell.getLinkedCells();
            for (Cell link:links) {
                double[] cent1 = cell.getContourCentroid();
                double[] cent2 = link.getContourCentroid();
                Line line = new Line(cent1[0],cent1[1],cent2[0],cent2[1]);
                line.setPosition(cell.getPosition());
                line.setStrokeColor(cell.getColour());
                overlay.add(line);

            }
        }

        // Adding the overlay to the image and saving
        renderIpl.setOverlay(overlay);
        IJ.save(renderIpl,pathOut);

    }

    private static ArrayList<Result> compileResult(Result templateResult, HashMap<Integer,ArrayList<Cell>> tracks, int[] cellsPerFrame) {
        ArrayList<Result> results = new ArrayList<>();

        // Runs through each track, creating a new Result object and adding it to the ArrayList of results.  Each track
        // is comprised of an ArrayList of Cells
        for (int key:tracks.keySet()) {
            ArrayList<Cell> cells = tracks.get(key);

            // Copying the fundamental parameters from the template
            Result result = new Result();
            result.setFile(templateResult.getFile());
            result.setWell(templateResult.getWell());
            result.setField(templateResult.getField());
            result.setComment(templateResult.getComment());

            // Setting the trackID number (one value per track)
            result.setTrackID(key);

            // Initialising the result arrays
            double[] x = new double[cells.size()];
            double[] y = new double[cells.size()];
            double[] frame = new double[cells.size()];
            double[] nLinks = new double[cells.size()];
            double[] nLinksNorm = new double[cells.size()];

            // Going through each cell for the current track and adding its information to the result arrays
            for (int idx = 0; idx < cells.size(); idx++) {
                Cell cell = cells.get(idx);

                double[] cent = cell.getContourCentroid();
                x[idx] = cent[0];
                y[idx] = cent[1];

                frame[idx] = cell.getPosition();

                nLinks[idx] = cell.getLinkedCells().size();

                int nCells = cell.getLinkedCells().size();
                int currNCellsPerFrame = cellsPerFrame[cell.getPosition() - 1];
                if (nCells != 0 & currNCellsPerFrame != 0) {
                    nLinksNorm[idx] = (double) nCells / (double) currNCellsPerFrame;
                } else {
                    nLinksNorm[idx] = Double.NaN;
                }
            }

            // Adding the result arrays to the result structure
            result.setX(x);
            result.setY(y);
            result.setFrame(frame);
            result.setnLinks(nLinks);
            result.setnLinksNorm(nLinksNorm);

            // Adding the current result to the ArrayList of results
            results.add(result);

        }

        return results;

    }

    private static void exportResultsXML(ArrayList<ArrayList<Result>> results, HashMap<String,Object> params) throws ParserConfigurationException, TransformerException {
        DecimalFormat dfDec = new DecimalFormat("0.##");
        DecimalFormat dfSci = new DecimalFormat("0.##E0");

        DocumentBuilderFactory docFactory = DocumentBuilderFactory.newInstance();
        DocumentBuilder docBuilder = docFactory.newDocumentBuilder();
        Document doc = docBuilder.newDocument();

        Element root = doc.createElement("ROOT");
        doc.appendChild(root);

        for (ArrayList<Result> currResults:results) {
            Element expElement = Exporter.summariseAll(doc,currResults.get(0));

            for (Result result:currResults) {
                Element trackElement = doc.createElement("TRACK");

                // Adding single values to TRACK element.  Currently the only thing to be added is the track ID;
                // however, further on we could add track-specific measures
                Attr trackID = doc.createAttribute("ID");
                trackID.appendChild(doc.createTextNode(String.valueOf(result.getTrackID())));
                trackElement.setAttributeNode(trackID);

                // Getting the mean and standard deviation for the duration of non-zero interaction runs
                Attr meanInteractionDuration = doc.createAttribute("MEAN_INT_DUR");
                meanInteractionDuration.appendChild(doc.createTextNode(String.valueOf(result.getMeanInteractionDuration())));
                trackElement.setAttributeNode(meanInteractionDuration);

                Attr stdInteractionDuration = doc.createAttribute("STD_INT_DUR");
                stdInteractionDuration.appendChild(doc.createTextNode(String.valueOf(result.getStdInteractionDuration())));
                trackElement.setAttributeNode(stdInteractionDuration);

                for (int i=0;i<result.x.length;i++) {
                    Element resElement = doc.createElement("RES");

                    Attr xAttr = doc.createAttribute("X");
                    xAttr.appendChild(doc.createTextNode(String.valueOf(dfDec.format(result.x[i]))));
                    resElement.setAttributeNode(xAttr);

                    Attr yAttr = doc.createAttribute("Y");
                    yAttr.appendChild(doc.createTextNode(String.valueOf(dfDec.format(result.y[i]))));
                    resElement.setAttributeNode(yAttr);

                    Attr frameAttr = doc.createAttribute("FR");
                    frameAttr.appendChild(doc.createTextNode(String.valueOf(result.frame[i])));
                    resElement.setAttributeNode(frameAttr);

                    Attr nLinksAttr = doc.createAttribute("N_LKS");
                    nLinksAttr.appendChild(doc.createTextNode(String.valueOf(result.nLinks[i])));
                    resElement.setAttributeNode(nLinksAttr);

                    Attr nLinksNormAttr = doc.createAttribute("N_LKS_N");
                    if (((Double) result.nLinks[i]).intValue()==0) {
                        nLinksNormAttr.appendChild(doc.createTextNode("NaN"));
                    } else {
                        nLinksNormAttr.appendChild(doc.createTextNode(String.valueOf(dfSci.format(result.nLinksNorm[i]))));
                    }
                    resElement.setAttributeNode(nLinksNormAttr);

                    trackElement.appendChild(resElement);

                }

                expElement.appendChild(trackElement);

            }

            root.appendChild(expElement);

        }

        TransformerFactory transformerFactory = TransformerFactory.newInstance();
        DOMSource source = new DOMSource(doc);
        StreamResult result = new StreamResult((String) params.get("Export_file"));

        Transformer transformer = transformerFactory.newTransformer();
        transformer.transform(source, result);

        IJ.log(" ");
        IJ.log("File saved!");

    }

    @Override
    public void run(String s) {
        try {
            new Relate_Cells().run();
        } catch (TransformerException | ParserConfigurationException e) {
            e.printStackTrace();
        }
    }
}

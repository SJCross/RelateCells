// TODO: Load single image

package wolfson.RelateCells

import fiji.plugin.trackmate.Logger
import fiji.plugin.trackmate.Model
import fiji.plugin.trackmate.Settings
import fiji.plugin.trackmate.Spot
import fiji.plugin.trackmate.TrackMate
import fiji.plugin.trackmate.detection.DetectorKeys
import fiji.plugin.trackmate.detection.LogDetectorFactory
import fiji.plugin.trackmate.features.spot.SpotIntensityAnalyzerFactory
import fiji.plugin.trackmate.tracking.LAPUtils
import fiji.plugin.trackmate.tracking.oldlap.SimpleLAPTrackerFactory
import ij.IJ
import ij.ImagePlus
import ij.Prefs
import ij.gui.GenericDialog
import ij.gui.Line
import ij.gui.OvalRoi
import ij.gui.Overlay
import ij.gui.PolygonRoi
import ij.gui.Roi
import ij.measure.Measurements
import ij.plugin.AVI_Reader
import ij.plugin.ChannelSplitter
import ij.plugin.Duplicator
import ij.plugin.ImageCalculator
import ij.plugin.PlugIn
import ij.plugin.RGBStackMerge
import ij.plugin.filter.BackgroundSubtracter
import ij.plugin.filter.GaussianBlur
import ij.plugin.filter.ParticleAnalyzer
import ij.plugin.frame.RoiManager
import ij.process.AutoThresholder
import ij.process.FloatPolygon
import ij.process.ImageConverter
import ij.process.StackConverter
import ij.process.StackProcessor
import ij.process.StackStatistics
import org.apache.commons.io.FilenameUtils
import org.apache.hadoop.hbase.util.MunkresAssignment
import wolfson.ImageJOps.SpotIntensity
import wolfson.common.FileConditions.ExtensionMatchesString
import wolfson.common.FileConditions.NameContainsPattern
import wolfson.common.FileConditions.NameContainsString
import wolfson.common.HighContent.HCExporter
import wolfson.common.HighContent.HCFilenameGenerator
import wolfson.common.HighContent.HCParameterExtractor
import wolfson.common.HighContent.HCPatterns
import wolfson.common.HighContent.HCResult
import wolfson.common.MathFunc.CumStat
import wolfson.common.System.FileCrawler

import javax.swing.JFileChooser
import javax.xml.parsers.DocumentBuilderFactory
import javax.xml.transform.Transformer
import javax.xml.transform.TransformerFactory
import javax.xml.transform.dom.DOMSource
import javax.xml.transform.stream.StreamResult
import java.awt.Color
import java.awt.Polygon
import java.text.DecimalFormat
import java.util.regex.Pattern

/**
 * Created by sc13967 on 14/03/2017.
 */
class Relate_Cells implements PlugIn{
    int maxCellID = 0 // Fluorescence-channel and phase-channel cells draw from the same pool

    static void main(String[] args) {
        new Relate_Cells().run()

    }

    void run() {
        // Starting ImageJ
        //new ImageJ()

        // Getting parameters via a generic dialog
        def params = getParameters()

        // Initialising ArrayList to hold results.  The overall result will hold an ArrayList of Result objects for that
        // experiment
        IJ.log("Initialising system")
        def results = new ArrayList<ArrayList<Result>>()

        // Setting up a condition to only load images with the IncuCyte filename format
        def filePattern = Pattern.compile(HCPatterns.incuCyteShortFilenamePattern)
        def filePatternCondition = new NameContainsPattern(filePattern, NameContainsPattern.INC_PARTIAL)

        // Setting up a condition to only load images containing the fluorescence name (i.e. fluorescence images)
        def fileNameCondition = new NameContainsString((String) params.get("Fl_name"),NameContainsString.INC_PARTIAL)

        // Setting up a condition which ignores the overlay images generated by this analysis
        def overlayCondition = new NameContainsString("celloverlay",NameContainsString.EXC_PARTIAL)

        // Setting up a condition to only load images with .tif, .tiff or .avi extensions
        String[] exts = ["tif", "tiff","avi"]
        def extensionConditon = new ExtensionMatchesString(exts)

        // Getting the root folder for analysis
        def rootFolder = new File((String) params.get("Root_folder"))

        // Initialising FileCrawler based on previously identified criteria
        def fileCrawler = new FileCrawler()
        fileCrawler.setRootFolder(rootFolder)
        fileCrawler.addFileCondition(filePatternCondition)
        fileCrawler.addFileCondition(fileNameCondition)
        fileCrawler.addFileCondition(overlayCondition)
        fileCrawler.addFileCondition(extensionConditon)

        // Calculating the number of files that will be processed
        def numFiles = fileCrawler.getNumberOfValidFilesInStructure()
        IJ.log(numFiles+" image stacks to process")

        // Re-initialising the FileCrawler
        fileCrawler = new FileCrawler()
        fileCrawler.setRootFolder(rootFolder)
        fileCrawler.addFileCondition(filePatternCondition)
        fileCrawler.addFileCondition(fileNameCondition)
        fileCrawler.addFileCondition(overlayCondition)
        fileCrawler.addFileCondition(extensionConditon)

        // Running through all compatible files in the structure
        int iter = 1
        def file = fileCrawler.getNextValidFileInStructure()
        while (file != null) {
            IJ.log(" ")
            IJ.log("Processing image stack " + iter + ":")

            // Creating the result structure for the current file
            IJ.log("    Extracting metadata:")
            def result = new Result()
            result.setFile1(file)
            new HCParameterExtractor(result).extractIncuCyteShortFile(file.name)
            IJ.log("        Well: " + result.well)
            IJ.log("        Field: " + result.field)

            // Loading current image stack
            def ipl = loadImages(file, result, params)

            if (ipl != null) {
                // Running stack alignment
                ipl = runDriftCorrection(ipl, params)

                // Running the cell relation process and adding the results to the cumulative results collection
                def currResults = runRelation(ipl, params, result)
                results.add(currResults)

            } else {
                IJ.log("    Missing phase contrast file")
            }

            // Loading the next valid file
            file = fileCrawler.getNextValidFileInStructure()

            iter++

        }

        exportResultsXML(results,params)

    }

    static HashMap<String,Object> getParameters() {

        def flName = (String) Prefs.get("RelateCells.flName","Green")
        def pHName = (String) Prefs.get("RelateCells.pHName","Phase")
        def borderWidth = (double) Prefs.get("RelateCells.borderWidth",5)
        def dogRadius = (double) Prefs.get("RelateCells.dogRadius",4)
        def threshMult = (double) Prefs.get("RelateCells.threshMult",1)
        def minSize = (double) Prefs.get("RelateCells.minSize",10)
        def maxSize = (double) Prefs.get("RelateCells.maxSize",100000)
        def maxEdgeDist = (double) Prefs.get("RelateCells.maxEdgeDist",20)
        def maxCentDist = (double) Prefs.get("RelateCells.maxCentDist",50)
        def invertIntensity = (boolean) Prefs.get("RelateCells.invertIntensity",false)
        def detectionRadius = (double) Prefs.get("RelateCells.detectionRadius",7.5)
        def threshold = (double) Prefs.get("RelateCells.threshold",2)
        def minIntensity = (double) Prefs.get("RelateCells.minIntensity",20)
        def saveDetection = (boolean) Prefs.get("RelateCells.saveDetection",true)


        GenericDialog gd = new GenericDialog("Parameters")
        gd.addMessage("GENERAL:")
        gd.addStringField("Fluorescence channel name",flName,4)
        gd.addStringField("Phase contrast channel name",pHName,4)
        gd.addNumericField("Border width (%): ",borderWidth,0)
        gd.addMessage(" ")
        gd.addMessage("FLUORESCENCE CHANNEL:")
        gd.addNumericField("DoG filter radius (px): ", dogRadius, 1)
        gd.addNumericField("Threshold multiplier: ", threshMult, 1)
        gd.addNumericField("Minimum cell size (px^2)", minSize, 1)
        gd.addNumericField("Maximum cell size (px^2)", maxSize, 1)
        gd.addNumericField(" Max. edge-edge distance (px): ", maxEdgeDist, 1)
        gd.addNumericField("Max. centroid-centroid distance (px): ", maxCentDist, 1)
        gd.addCheckbox("Invert intensity",invertIntensity)
        gd.addMessage(" ")
        gd.addMessage("PHASE CONTRAST CHANNEL:")
        gd.addNumericField("Detection radius (px): ", detectionRadius, 1)
        gd.addNumericField("Threshold (px): ", threshold, 1)
        gd.addNumericField("Minimum intensity (AU): ",minIntensity,20)
        gd.addMessage(" ")
        gd.addMessage("OUTPUT:")
        gd.addCheckbox("Save detection and links",saveDetection)

        gd.showDialog()

        // Parameters
        flName = (String) gd.getNextString()
        pHName = (String) gd.getNextString()
        borderWidth = (double) gd.getNextNumber()
        dogRadius = (double) gd.getNextNumber()
        threshMult = (double) gd.getNextNumber()
        minSize = (double) gd.getNextNumber()
        maxSize = (double) gd.getNextNumber()
        maxEdgeDist = (double) gd.getNextNumber()
        maxCentDist = (double) gd.getNextNumber()
        invertIntensity = (boolean) gd.getNextBoolean()
        detectionRadius = (double) gd.getNextNumber()
        threshold = (double) gd.getNextNumber()
        minIntensity = (double) gd.getNextNumber()
        saveDetection = (boolean) gd.getNextBoolean()

        HashMap<String,Object> params = new HashMap<String, Object>()
        params.put("Fl_name",flName)
        params.put("Ph_name",pHName)
        params.put("Border_width",borderWidth) // Percentage width of the border following drift correction
        params.put("DoG_Radius",dogRadius) // Radius for smaller Gaussian blur in DoG filtering (larger is 1.6*dogR)
        params.put("Threshold_multiplier",threshMult)
        params.put("Min_fl_cell_size",minSize)
        params.put("Max_fl_cell_size",maxSize)
        params.put("Max_Link_Threshold",maxEdgeDist) // Distance in px from one cell boundary to the other
        params.put("Centroid_Link_Threshold",maxCentDist) // Centroid distance for accurate edge-edge distance to be calculated
        params.put("Invert_intensity",invertIntensity) // Inverting the intensity appears necessary for some ImageJ versions (not sure why yet)
        params.put("TrackMate_Radius",detectionRadius)
        params.put("TrackMate_Threshold",threshold)
        params.put("Min_ph_intensity",minIntensity)
        params.put("Display_Links",saveDetection)

        // Getting root folder for analysis
        def rootFolder = getRootFolder()
        params.put("Root_folder",rootFolder.absolutePath)

        // Getting export location for the Excel file
        def exportFile = getExportLocation()
        params.put("Export_file",exportFile.getAbsolutePath())

        return params

    }

    static File getRootFolder() {
        // Opening the file dialog.  Only directories can be selected
        def openFileDialog = new JFileChooser("C:\\Users\\sc13967\\Google Drive\\People\\H\\Lea Hampton-O'Neil\\2017-03-07 Cell association (Incucyte)\\Batch data\\Crop")
        openFileDialog.setDialogTitle("Select the root folder")
        openFileDialog.setMultiSelectionEnabled(false)
        openFileDialog.setFileSelectionMode(JFileChooser.DIRECTORIES_ONLY)
        openFileDialog.showOpenDialog(null)
        def rootFolder = openFileDialog.getSelectedFile()

        return rootFolder

    }

    static File getExportLocation() {
        // Opening the file dialog.  Only directories can be selected
        def openFileDialog = new JFileChooser()
        openFileDialog.setDialogTitle("Select file to save")
        openFileDialog.setMultiSelectionEnabled(false)
        openFileDialog.setFileSelectionMode(JFileChooser.FILES_ONLY)
        openFileDialog.showOpenDialog(null)
        def exportFile = openFileDialog.getSelectedFile()

        return exportFile

    }

    static ImagePlus loadImages(File file, HCResult result, HashMap<String,Object> params) {
        // Getting the filename for the corresponding phase-contrast image
        def comment = result.comment
        comment = comment.replaceAll((String) params.get("Fl_name"),(String) params.get("Ph_name"))
        def phFilename = HCFilenameGenerator.generateIncuCyteShortFile(comment,result.well,result.field,result.ext)

        // Creating structure to hold both image stacks
        def ipls = new ImagePlus[2]

        // Checking the phase channel also exists
        if (new File(file.getParentFile().absolutePath + "\\" + phFilename).exists()) {
            // Selecting the method to use for image opening depending on the file type
            if (result.ext == "avi") {
                // Loading the current fluorescence channel file to ImageJ
                IJ.log("    Loading fluorescence image stack (" + file.name + ")")
                ipls[0] = AVI_Reader.open(file.absolutePath, false)
                new StackConverter(ipls[0]).convertToGray8()

                // Loading the current phase-contrast channel file to ImageJ
                IJ.log("    Loading phase-contrast image stack (" + phFilename + ")")
                ipls[1] = AVI_Reader.open(file.getParentFile().absolutePath + "\\" + phFilename, false)
                new StackConverter(ipls[1]).convertToGray8()

            } else if (result.ext == "tif" | result.ext == "tiff") {
                // Loading the current fluorescence channel file to ImageJ
                IJ.log("    Loading fluorescence image stack (" + file.name + ")")
                ipls[0] = IJ.openImage(file.absolutePath)

                // Loading the current phase-contrast channel file to ImageJ
                IJ.log("    Loading phase-contrast image stack (" + phFilename + ")")
                ipls[1] = IJ.openImage(file.getParentFile().absolutePath + "\\" + phFilename)

            }

            // Combining the two images for stack registration
            IJ.log("    Creating composite image")
            def ipl = RGBStackMerge.mergeChannels(ipls, false)

            // Converting ImagePlus to time-based if there are more slices than frames and the number of frames is 1
            if (ipl.getNSlices() > 1 & ipl.getNFrames() == 1) {
                switchTimeAndZ(ipl)
            }

            return ipl

        } else {
            return null

        }

    }

    static ImagePlus runDriftCorrection(ImagePlus ipl, HashMap<String,Object> params) {
        new StackConverter(ipl).convertToRGB()

        // Running stack registration
        IJ.log("    Aligning image stack using StackReg")
        ipl.setT(ipl.getNFrames())
        IJ.run(ipl,"StackReg","transformation=Translation")

        //Converting back to a composite image
        def ipls = new ChannelSplitter().split(ipl)
        ImagePlus[] ipls2 = [ipls[0],ipls[1]]
        ipl = RGBStackMerge.mergeChannels(ipls2,false)

        // Cropping the image to the central region
        def borderFrac = (double) params.get("Border_width")/100
        def w = ipl.getWidth()
        def h = ipl.getHeight()
        def ist = new StackProcessor(ipl.getStack()).crop((w*borderFrac).intValue(),(h*borderFrac).intValue(),(w*(1-2*borderFrac)).intValue(),(h*(1-2*borderFrac)).intValue())
        ipl.setStack(ist)

        // Converting ImagePlus to time-based if there are more slices than frames and the number of frames is 1
        if (ipl.getNSlices() > 1 & ipl.getNFrames() == 1) {
            switchTimeAndZ(ipl)
        }

        return ipl

    }

    ArrayList<Result> runRelation(ImagePlus ipl, HashMap<String,Object> params, Result templateResult) {
        // Getting the separate channels
        def ipls = new ChannelSplitter().split(ipl)

        // Calculating the difference of Gaussian for the phase-contrast channel
        IJ.log("    Running DoG filter on phase-contrast channel")
        def phaseIpl = runDoG(ipls[1],(double) params.get("DoG_Radius"))

        // Creating a separate image to perform fluorescence operations on
        def fluorIpl = new Duplicator().run(ipls[0])

        // Detecting cells in the phase-contrast channel
        IJ.log("    Detecting cells in phase-contrast channel using TrackMate")
        ArrayList<Cell> phCells = detectPhaseContrastCells(phaseIpl, ipls[1], params)
        IJ.log("        "+phCells.size()+" instances found")

        // Detecting cells in the fluorescence channel
        IJ.log("    Detecting cells in fluorescence channel")
        ArrayList<Cell> flCells = detectFluorescentCells(fluorIpl, params)
        IJ.log("        "+flCells.size()+" instances found")

        // Linking phase contrast cells to tracks
        IJ.log("    Tracking cells in fluorescence channel using Apache HBase (MunkresAssignment)")
        def tracks = trackCells(flCells)
        IJ.log("        "+tracks.size()+" tracks created")

        // Removing overlapping cells (where fluorescent cells were detected in the phase channel)
        IJ.log("    Removing overlapping cells")
        removingCellOverlap(phCells, flCells)

        // Linking phase channel cells to fluorescence channel cells
        IJ.log("    Linking fluorescence and phase-contrast cells")
        compareCellPositions(phCells, flCells, (double) params.get("Max_Link_Threshold"), (double) params.get("Centroid_Link_Threshold"))

        // Calculating number of phase cells per frame
        IJ.log("    Calculating number of cells per frame in phase-contrast channel")
        def phCellsPerFrame = measureNumCellsPerFrame(phCells, ipl.getNFrames())

        // Displaying the tracked cells on the fluorescence channel
        if (params.get("Display_Links")) {
            IJ.log("    Saving overlay image")
            def outPname = FilenameUtils.removeExtension(templateResult.getFile1().getAbsolutePath())+"_celloverlay.tif"
            showLinkedCells(phCells, flCells, ipl, outPname)

        }

        // Compiling results into an ArrayList of results
        def currResults = compileResult(templateResult,tracks,phCellsPerFrame)

        return currResults

    }

/**
 * Converts a hyperstack with time listed in the Z-dimension to having frames in T.  Uses the same approach as
 * TrackMate
 * @param ipl Input ImagePlus
 */
    static void switchTimeAndZ(ImagePlus ipl) {
        def dimensions = ipl.getDimensions()
        ipl.setDimensions(dimensions[2],dimensions[4],dimensions[3])

    }

    static ImagePlus runDoG(ImagePlus ipl, double sigma) {
        // Duplicating the input ImagePlus
        def ipl1 = new Duplicator().run(ipl)
        def ipl2 = new Duplicator().run(ipl)

        // Converting both ImagePlus into 32-bit, to give a smoother final result
        new ImageConverter(ipl1).convertToGray32()
        new ImageConverter(ipl2).convertToGray32()

        // Performing the next couple of steps on all slices
        for (int i = 0; i < ipl.getNFrames(); i++) {
            // Setting the current slice number
            ipl1.setT(i+1)
            ipl2.setT(i+1)

            // Multiplying the intensities by 10, to give a smoother final result
            ipl1.getProcessor() * 10
            ipl2.getProcessor() * 10

            // Running Gaussian blur at two length scales.  One 1.6 times larger than the other (based on discussion at
            // http://dsp.stackexchange.com/questions/2529/what-is-the-relationship-between-the-sigma-in-the-laplacian-of-
            // gaussian-and-the (Accessed 14-03-2017)
            new GaussianBlur().blurGaussian(ipl1.getProcessor(), sigma, sigma, 0.01)
            new GaussianBlur().blurGaussian(ipl2.getProcessor(), sigma * 1.6, sigma * 1.6, 0.01)
        }

        // Subtracting one from the other to give the final DoG result
        def iplOut = new ImageCalculator().run("Subtract create stack 32-bit",ipl2,ipl1)

        new ImageConverter(iplOut).convertToGray8()

        return iplOut

    }

    ArrayList<Cell> detectPhaseContrastCells(ImagePlus ipl, ImagePlus rawIpl, HashMap<String,Object> params) {
        def model = new Model()

        // Disabling logging
        model.setLogger(Logger.VOID_LOGGER)

        def settings = new Settings()
        settings.setFrom(ipl)

        settings.detectorFactory = new LogDetectorFactory()
        settings.detectorSettings.put(DetectorKeys.KEY_DO_SUBPIXEL_LOCALIZATION,true)
        settings.detectorSettings.put(DetectorKeys.KEY_RADIUS,(Double) params.get("TrackMate_Radius"))
        settings.detectorSettings.put(DetectorKeys.KEY_TARGET_CHANNEL,(Integer) 1)
        settings.detectorSettings.put(DetectorKeys.KEY_THRESHOLD,(Double) params.get("TrackMate_Threshold"))
        settings.detectorSettings.put(DetectorKeys.KEY_DO_MEDIAN_FILTERING,false)

        settings.trackerFactory = new SimpleLAPTrackerFactory()
        settings.trackerSettings = LAPUtils.getDefaultLAPSettingsMap()

        settings.addSpotAnalyzerFactory(new SpotIntensityAnalyzerFactory())

        def trackmate = new TrackMate(model,settings)

        if (!trackmate.checkInput()) {
            IJ.log(trackmate.getErrorMessage())
        }

        trackmate.execDetection()
        trackmate.execInitialSpotFiltering()
        trackmate.computeSpotFeatures(true)
        trackmate.execSpotFiltering(true)

        def cells = new ArrayList<Cell>()
        def spots = model.getSpots()
        def minInt = (double) params.get("Min_ph_intensity")

        spots.iterable(true).each {
            // Removing black cells, which can arise when they are accidentally detected at the image edge following
            // drift correction
            def intensity = new SpotIntensity(rawIpl,it.getFeature(Spot.POSITION_X),it.getFeature(Spot.POSITION_Y),it.getFeature(Spot.RADIUS)/1.5,it.getFeature(Spot.POSITION_T).intValue())

            if (intensity.meanPointIntensity > minInt) {
                def rad = it.getFeature(Spot.RADIUS)
                def ovalRoi = new OvalRoi(it.getFeature(Spot.POSITION_X) - rad, it.getFeature(Spot.POSITION_Y) - rad, rad * 2, rad * 2)
                def cell = new Cell(ovalRoi.getFloatPolygon().xpoints, ovalRoi.getFloatPolygon().ypoints, Roi.POLYGON)
                cell.setPosition(it.getFeature(Spot.POSITION_T).intValue() + 1)
                cell.setCellID(maxCellID++)

                cells.add(cell)
            }
        }

        return cells
    }

    ArrayList<Cell> detectFluorescentCells(ImagePlus ipl, HashMap<String,Object> params) {
        // Applying basic image processing to clean up the image
        // Performing the next couple of steps on all slices
        for (int i = 0; i < ipl.getNFrames(); i++) {
            // Setting the current slice number
            def frame = i+1
            ipl.setT(frame)

            new BackgroundSubtracter().rollingBallBackground(ipl.getProcessor(),50,false,false,false,true,true)
            new GaussianBlur().blurGaussian(ipl.getProcessor(),2,2,0.01)

        }

        // Getting the stack intensity histogram
        def stackStats = new StackStatistics(ipl)
        def statLong = stackStats.histogram
        def statInt = new int[statLong.length]

        // Converting long-format image stack histogram measurements to int-format
        for (int i=0;i<statLong.length;i++) {
            statInt[i] = Math.toIntExact(statLong[i])
        }

        // Determining the threshold (Huang method) and casting to double, for the multiplication step
        def thresh = (double) new AutoThresholder().getThreshold(AutoThresholder.Method.Otsu,statInt)
        IJ.log("        Threshold (Otsu) set to "+thresh)

        // Applying user-specified offset, the converting back to int
        thresh = (thresh*(double) params.get("Threshold_multiplier")).intValue()
        IJ.log("        Threshold offset to "+thresh+" ("+(double) params.get("Threshold_multiplier")+"x)")

        // Running the threshold on each image in the stack
        for (int i=0;i<ipl.getNFrames();i++) {
            ipl.setT(i+1)
            ipl.getProcessor().threshold(thresh)

        }

        // Creating a container for the cells and a RoiManager, where the results will be stored temporarily
        def cells = new ArrayList<Cell>()
        def rois = RoiManager.getRoiManager()
        rois.setVisible(false)

        // Running through each slice (frame), detecting the particles
        for (int frame=0;frame<ipl.getNFrames();frame++) {
            ipl.setT(frame+1)

            // Inverting the intensity.  This seems necessary for some versions of ImageJ, but not others :/
            if ((boolean) params.get("Invert_intensity")) {
                ipl.getProcessor().invert()
            }

            // Running analyse particles
            def partAnal = new ParticleAnalyzer(ParticleAnalyzer.EXCLUDE_EDGE_PARTICLES, Measurements.AREA | Measurements.CENTROID, null, (int) params.get("Min_fl_cell_size"), (int) params.get("Max_fl_cell_size"), 0, 1)
            partAnal.setRoiManager(rois)
            partAnal.analyze(ipl)

            // Adding all current rois to the cell arraylist
            for (int i = 0; i < rois.count; i++) {
                def cell = new Cell(rois.getRoi(i).polygon, PolygonRoi.POLYGON)
                cell.setPosition(frame+1)
                cell.setCellID(maxCellID++)
                cells.add(cell)
            }

            // Removing the previously-detected ROIs from the RoiManager
            rois.reset()
        }

        return cells

    }

/**
 * Links cells using the Munkres algorithm.
 * @param cells
 * @return HashMap containing ArrayLists of cells, sorted by the TrackID number
 */
    static HashMap<Integer,ArrayList<Cell>> trackCells(ArrayList<Cell> cells) {
        def maxDist = 100

        def tracks = new HashMap<Integer,ArrayList<Cell>>()

        // Getting the maximum frame number
        def maxFr = 0
        cells.each {
            if (it.getPosition() > maxFr) {
                maxFr = it.getPosition()
            }
        }

        def trackID = 0

        def rand = new Random(System.currentTimeMillis())
        // Assigning new trackIDs to all cells in the first frame
        cells.each {
            if (it.getPosition() == 1) {
                // Assigning the next available track number to this track
                it.setTrackID(trackID++)

                // Creating a new track ArrayList and adding it to the tracks ArrayList
                def track = new ArrayList<Cell>()
                track.add(it)
                tracks.put(it.getTrackID(),track)

                // Assigning a random colour to this new track
                it.setColour(Color.getHSBColor(rand.nextFloat(),1,1))
            }
        }

        // Going through each frame, getting the current cells and the ones from the previous frame
        for (int fr = 2;fr <= maxFr; fr++) {
            def prevCells = new ArrayList<Cell>()
            def currCells = new ArrayList<Cell>()

            cells.each {
                if (it.getPosition() + 1 == fr) {
                    prevCells.add(it)
                } else if (it.getPosition() == fr) {
                    currCells.add(it)
                }
            }

            if (currCells.size() > 0) {
                // Creating a 2D cost matrix for the overlap.  A maximum linking distance is specified, above which costs are Inf
                def cost = new float[currCells.size()][prevCells.size()]
                for (int curr = 0; curr < cost.length; curr++) {
                    for (int prev = 0; prev < cost[0].length; prev++) {
                        def currCent = currCells.get(curr).contourCentroid
                        def prevCent = prevCells.get(prev).contourCentroid

                        def dist = Math.sqrt((prevCent[0] - currCent[0]) * (prevCent[0] - currCent[0]) + (prevCent[1] - currCent[1]) * (prevCent[1] - currCent[1]))

                        if (dist < maxDist) {
                            cost[curr][prev] = dist
                        } else {
                            cost[curr][prev] = Float.MAX_VALUE
                        }
                    }
                }

                // Running the Munkres algorithm to assign matches.
                def assignment = new MunkresAssignment(cost).solve()

                // Applying the calculated track IDs to the cells
                for (int curr = 0; curr < assignment.size(); curr++) {
                    if (assignment[curr] == -1) {
                        def currCell = currCells.get(curr)
                        // Assigning the next available track number to this track
                        currCell.setTrackID(trackID++)

                        // Creating a new track ArrayList and adding it to the tracks ArrayList
                        def track = new ArrayList<Cell>()
                        track.add(currCell)
                        tracks.put(currCell.getTrackID(), track)

                        // Assigning a random colour to this new track
                        currCell.setColour(Color.getHSBColor(rand.nextFloat(), 1, 1))

                    } else {
                        // Applying TrackID and colour from the previous cell to the newly linked cell
                        def prevCell = prevCells.get(assignment[curr])
                        def currCell = currCells.get(curr)
                        currCell.setTrackID(prevCell.getTrackID())
                        currCell.setColour(prevCell.getColour())

                        // Adding the new object to that track
                        tracks.get(prevCell.getTrackID()).add(currCell)

                    }
                }
            }
        }

        return tracks

    }

    static void removingCellOverlap(ArrayList<Cell> phCells, ArrayList<Cell> flCells) {
        for (int i=phCells.size()-1;i>=0;i--) {
            IJ.showProgress((phCells.size() - i) / phCells.size())
            def phCell = phCells.get(i)
            for (def flCell : flCells) {
                // Only testing for a link if the cells are visible in the same frame
                if (phCell.getPosition() == flCell.getPosition()) {
                    // Performing a crude spatial test to check if they are remotely close
                    def phCent = phCell.contourCentroid

                    // Testing if the phase channel cell is within the boundary of the fluorescent channel cell.  This
                    // can arise from mis-detection during the DoG/TrackMate steps
                    if (flCell.contains(phCent[0].intValue(), phCent[1].intValue())) {
                        phCells.remove(i)

                    }
                }
            }
        }
    }

/**
 * Basic analysis taking cells in each frame as isolated objects.
 * @param cells1
 * @param cells2
 */
    static void compareCellPositions(ArrayList<Cell> phCells, ArrayList<Cell> flCells, double maxLinkDist, double centLinkDist) {
        // Running through all cells in both the fluorescence and phase channels

        for (int i=phCells.size()-1;i>=0;i--) {
            IJ.showProgress((phCells.size()-i)/phCells.size())
            def phCell = phCells.get(i)
            for (def flCell:flCells) {
                // Only testing for a link if the cells are visible in the same frame
                if (phCell.getPosition() == flCell.getPosition()) {
                    // Performing a crude spatial test to check if they are remotely close
                    def phCent = phCell.contourCentroid
                    def flCent = flCell.contourCentroid

                    // Calculating a crude centre-centre cell distance to identify cells for further comparison
                    def centDist = Math.sqrt((phCent[0] - flCent[0]) * (phCent[0] - flCent[0]) + (phCent[1] - flCent[1]) * (phCent[1] - flCent[1]))

                    if (centDist < centLinkDist) {
                        // Calculating the distance between the cells
                        def dist = flCell.measureDistanceToCell(phCell)

                        // If the distance is less than the user-defined threshold ("maxLinkDist") adding reference to
                        // the other cell in each cell's linkedCells ArrayList
                        if (dist < maxLinkDist) {
                            flCell.addLinkedCell(phCell)
                            phCell.addLinkedCell(flCell)

                        }
                    }
                }
            }
        }
    }

    static int[] measureNumCellsPerFrame(ArrayList<Cell> cells, int nFrames) {
        // Initialising the results array
        def numCells = new int[nFrames]

        cells.each {
            numCells[it.getPosition()-1]++
        }

        return numCells

    }

    static void showLinkedCells(ArrayList<Cell> phCells, ArrayList<Cell> flCells, ImagePlus ipl, String pathOut) {
        def overlay = new Overlay()

        // Adding phase-channel cells to the overlay
        phCells.each {
            it.setStrokeColor(it.getColour())
            overlay.add(it)

        }

        // Creating a new copy of the input image to draw the overlay on and save
        ImagePlus renderIpl = new Duplicator().run(ipl)

        // Setting LUTs for the two channels
        renderIpl.setC(1)
        IJ.run(renderIpl,"Green","")
        renderIpl.setC(2)
        IJ.run(renderIpl,"Grays","")

        new StackConverter(renderIpl).convertToRGB()

        // Adding fluorescence-channel cells to the overlay and links to phase channel cells
        flCells.each {
            it.setStrokeColor(it.getColour())
            overlay.add(it)

            def links = it.getLinkedCells()
            for (def link:links) {
                def cent1 = it.contourCentroid
                def cent2 = link.contourCentroid
                def line = new Line(cent1[0],cent1[1],cent2[0],cent2[1])
                line.setPosition(it.getPosition())
                line.setStrokeColor(it.getColour())
                overlay.add(line)

            }
        }

        // Adding the overlay to the image and saving
        renderIpl.setOverlay(overlay)
        IJ.save(renderIpl,pathOut)

    }

    static ArrayList<Result> compileResult(Result templateResult, HashMap<Integer,ArrayList<Cell>> tracks, int[] cellsPerFrame) {
        def results = new ArrayList<Result>()

        // Runs through each track, creating a new Result object and adding it to the ArrayList of results.  Each track
        // is comprised of an ArrayList of Cells
        tracks.each { track ->
            // Copying the fundamental parameters from the template
            def result = new Result()
            result.setFile1(templateResult.getFile1())
            result.setWell(templateResult.well)
            result.setField(templateResult.field)
            result.setComment(templateResult.comment)

            // Getting the cells of the current track
            def cells = track.getValue()

            // Setting the trackID number (one value per track)
            result.setTrackID(track.getKey())

            // Initialising the result arrays
            def x = new double[cells.size()]
            def y = new double[cells.size()]
            def frame = new double[cells.size()]
            def nLinks = new double[cells.size()]
            def nLinksNorm = new double[cells.size()]

            // Going through each cell for the current track and adding its information to the result arrays
            cells.eachWithIndex { cell, idx ->
                def cent = cell.contourCentroid
                x[idx] = cent[0]
                y[idx] = cent[1]

                frame[idx] = cell.getPosition()

                nLinks[idx] = cell.getLinkedCells().size()

                int nCells = cell.getLinkedCells().size()
                int currNCellsPerFrame = cellsPerFrame[cell.getPosition()-1]
                if (nCells != 0 & currNCellsPerFrame != 0) {
                    nLinksNorm[idx] = nCells/currNCellsPerFrame
                } else {
                    nLinksNorm[idx] = Double.NaN
                }

            }

            // Adding the result arrays to the result structure
            result.setX(x)
            result.setY(y)
            result.setFrame(frame)
            result.setnLinks(nLinks)
            result.setnLinksNorm(nLinksNorm)

            // Adding the current result to the ArrayList of results
            results.add(result)

        }

        return results

    }

    static void exportResultsXML(ArrayList<ArrayList<Result>> results, HashMap<String,Object> params) {
        def dfDec = new DecimalFormat("0.##")
        def dfSci = new DecimalFormat("0.##E0")

        def docFactory = DocumentBuilderFactory.newInstance()
        def docBuilder = docFactory.newDocumentBuilder()
        def doc = docBuilder.newDocument()

        def root = doc.createElement("ROOT")
        doc.appendChild(root)

        results.each { currResults ->
            def expElement = HCExporter.summariseAll(doc,currResults.get(0),"EXPERIMENT")

            currResults.each { result ->
                def trackElement = doc.createElement("TRACK")

                // Adding single values to TRACK element.  Currently the only thing to be added is the track ID;
                // however, further on we could add track-specific measures
                def trackID = doc.createAttribute("ID")
                trackID.appendChild(doc.createTextNode(String.valueOf(result.getTrackID())))
                trackElement.setAttributeNode(trackID)

                // Getting the mean and standard deviation for the duration of non-zero interaction runs
                def meanInteractionDuration = doc.createAttribute("MEAN_INT_DUR")
                meanInteractionDuration.appendChild(doc.createTextNode(String.valueOf(result.meanInteractionDuration)))
                trackElement.setAttributeNode(meanInteractionDuration)

                def stdInteractionDuration = doc.createAttribute("STD_INT_DUR")
                stdInteractionDuration.appendChild(doc.createTextNode(String.valueOf(result.stdInteractionDuration)))
                trackElement.setAttributeNode(stdInteractionDuration)

                for (int i=0;i<result.x.length;i++) {
                    def resElement = doc.createElement("RES")

                    def xAttr = doc.createAttribute("X")
                    xAttr.appendChild(doc.createTextNode(String.valueOf(dfDec.format(result.x[i]))))
                    resElement.setAttributeNode(xAttr)

                    def yAttr = doc.createAttribute("Y")
                    yAttr.appendChild(doc.createTextNode(String.valueOf(dfDec.format(result.y[i]))))
                    resElement.setAttributeNode(yAttr)

                    def frameAttr = doc.createAttribute("FR")
                    frameAttr.appendChild(doc.createTextNode(String.valueOf(result.frame[i])))
                    resElement.setAttributeNode(frameAttr)

                    def nLinksAttr = doc.createAttribute("N_LKS")
                    nLinksAttr.appendChild(doc.createTextNode(String.valueOf(result.nLinks[i])))
                    resElement.setAttributeNode(nLinksAttr)

                    def nLinksNormAttr = doc.createAttribute("N_LKS_N")
                    if (result.nLinks[i].intValue()==0) {
                        nLinksNormAttr.appendChild(doc.createTextNode("NaN"))
                    } else {
                        nLinksNormAttr.appendChild(doc.createTextNode(String.valueOf(dfSci.format(result.nLinksNorm[i]))))
                    }
                    resElement.setAttributeNode(nLinksNormAttr)

                    trackElement.appendChild(resElement)

                }

                expElement.appendChild(trackElement)

            }

            root.appendChild(expElement)

        }

        TransformerFactory transformerFactory = TransformerFactory.newInstance()
        DOMSource source = new DOMSource(doc)
        StreamResult result = new StreamResult((String) params.get("Export_file"))

        Transformer transformer = transformerFactory.newTransformer()
        transformer.transform(source, result)

        IJ.log(" ")
        IJ.log("File saved!")

    }

    @Override
    void run(String s) {
        new Relate_Cells().run()
    }
}

class Cell extends PolygonRoi {
    int cellID = -1
    int trackID = -1
    def colour = Color.getHSBColor(1,1,1)
    def linkedCells = new ArrayList<Cell>()


    // CONSTRUCTORS

    Cell(int[] xPoints, int[] yPoints, int nPoints, int type) {
        super(xPoints, yPoints, nPoints, type)
    }

    Cell(float[] xPoints, float[] yPoints, int nPoints, int type) {
        super(xPoints, yPoints, nPoints, type)
    }

    Cell(float[] xPoints, float[] yPoints, int type) {
        super(xPoints, yPoints, type)
    }

    Cell(Polygon p, int type) {
        super(p, type)
    }

    Cell(FloatPolygon p, int type) {
        super(p, type)
    }

    Cell(int sx, int sy, ImagePlus imp) {
        super(sx, sy, imp)
    }


    // PUBLIC METHODS
    /**
     * Measures the closest edge-edge separation between the cell and a second, user-specified cell
     * @return
     */
    double measureDistanceToCell(Cell cell2) {
        def x1 = floatPolygon.xpoints
        def y1 = floatPolygon.ypoints
        def x2 = cell2.floatPolygon.xpoints
        def y2 = cell2.floatPolygon.ypoints

        def minDist = Double.MAX_VALUE
        for (int i=0;i<x1.length;i++) {
            for (int j=0;j<x2.length;j++) {
                def dist = Math.sqrt((x2[j]-x1[i])*(x2[j]-x1[i])+(y2[j]-y1[i])*(y2[j]-y1[i]))
                if (dist < minDist) {
                    minDist = dist
                }
            }
        }

        return minDist

    }

    void addLinkedCell(Cell cell) {
        linkedCells.add(cell)
    }

    void removeLinkedCell(Cell cell) {
        linkedCells.remove(cell)
    }
}

class Result extends HCResult {
    def x = new double[0]
    def y = new double[0]
    def frame = new double[0]
    def nLinks = new int[0]
    def nLinksNorm = new int[0]
    int trackID = -1
    double meanInteractionDuration = -1
    double stdInteractionDuration = -1

    void calculateInteractionDuration() {
        def cs = new CumStat(1)

        def currDur = 0
        nLinks.each {
            if (it == 0) {
                if (currDur != 0) {
                    // Terminates the current run
                    cs.addMeasure(currDur)
                    currDur = 0
                }

            } else {
                // This is still a non-zero interaction run
                currDur++

            }
        }

        // Adding the final count
        if (currDur != 0) {
            cs.addMeasure(currDur)
        }

        // Assigns the relevant variables
        meanInteractionDuration = cs.mean[0]
        stdInteractionDuration = cs.std[0]

    }

    double getMeanInteractionDuration() {
        // Checks if the relevant statistic has already been calculated.  If not, it runs it
        if (meanInteractionDuration == -1) {
            calculateInteractionDuration()
        }

        return meanInteractionDuration

    }

    double getStdInteractionDuration() {
        // Checks if the relevant statistic has already been calculated.  If not, it runs it
        if (stdInteractionDuration == -1) {
            calculateInteractionDuration()
        }

        return stdInteractionDuration

    }
}